"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/context/AuthContext.tsx":
/*!*************************************!*\
  !*** ./src/context/AuthContext.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthProvider: function() { return /* binding */ AuthProvider; },\n/* harmony export */   useAuth: function() { return /* binding */ useAuth; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ AuthProvider,useAuth auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\nconst AuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst REFRESH_THRESHOLD = 5 * 60 * 1000;\nfunction AuthProvider(param) {\n    let { children } = param;\n    _s();\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [tokens, setTokens] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const storeTokens = function(accessToken, refreshToken) {\n        let expiresIn = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3600;\n        const expiresAt = Date.now() + expiresIn * 1000;\n        const newTokens = {\n            accessToken,\n            refreshToken,\n            expiresAt\n        };\n        setTokens(newTokens);\n        localStorage.setItem(\"authTokens\", JSON.stringify(newTokens));\n    };\n    const clearTokens = ()=>{\n        setTokens(null);\n        localStorage.removeItem(\"authTokens\");\n        localStorage.removeItem(\"user\");\n    };\n    const getAuthHeader = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        const storedTokens = JSON.parse(localStorage.getItem(\"authTokens\") || \"null\");\n        const accessToken = (tokens === null || tokens === void 0 ? void 0 : tokens.accessToken) || (storedTokens === null || storedTokens === void 0 ? void 0 : storedTokens.accessToken);\n        if (!accessToken) return {};\n        return {\n            Authorization: \"Bearer \".concat(accessToken)\n        };\n    }, [\n        tokens\n    ]);\n    const refreshSession = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async ()=>{\n        const storedTokens = tokens || JSON.parse(localStorage.getItem(\"authTokens\") || \"null\");\n        if (!(storedTokens === null || storedTokens === void 0 ? void 0 : storedTokens.refreshToken)) {\n            return false;\n        }\n        try {\n            const response = await fetch(\"/api/auth/refresh\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    refreshToken: storedTokens.refreshToken\n                })\n            });\n            if (!response.ok) {\n                clearTokens();\n                setUser(null);\n                return false;\n            }\n            const data = await response.json();\n            storeTokens(data.access, data.refresh, 3600);\n            return true;\n        } catch (error) {\n            console.error(\"Token refresh failed:\", error);\n            return false;\n        }\n    }, [\n        tokens\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!tokens) return;\n        const timeUntilExpiry = tokens.expiresAt - Date.now();\n        const refreshTime = timeUntilExpiry - REFRESH_THRESHOLD;\n        if (refreshTime <= 0) {\n            refreshSession();\n            return;\n        }\n        const timer = setTimeout(()=>{\n            refreshSession();\n        }, refreshTime);\n        return ()=>clearTimeout(timer);\n    }, [\n        tokens,\n        refreshSession\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const checkAuth = async ()=>{\n            const storedTokens = JSON.parse(localStorage.getItem(\"authTokens\") || \"null\");\n            const storedUser = JSON.parse(localStorage.getItem(\"user\") || \"null\");\n            if (storedTokens && storedUser) {\n                setTokens(storedTokens);\n                setUser(storedUser);\n                if (storedTokens.expiresAt - Date.now() < REFRESH_THRESHOLD) {\n                    await refreshSession();\n                } else {\n                    try {\n                        const response = await fetch(\"/api/auth/me\", {\n                            headers: {\n                                Authorization: \"Bearer \".concat(storedTokens.accessToken)\n                            }\n                        });\n                        if (response.ok) {\n                            const userData = await response.json();\n                            const userObj = {\n                                id: userData.id,\n                                email: userData.email,\n                                fullName: \"\".concat(userData.first_name || \"\", \" \").concat(userData.last_name || \"\").trim(),\n                                displayName: userData.username,\n                                role: userData.role\n                            };\n                            // Only update if it's actually different to avoid unnecessary re-renders\n                            if (JSON.stringify(userObj) !== JSON.stringify(storedUser)) {\n                                setUser(userObj);\n                                localStorage.setItem(\"user\", JSON.stringify(userObj));\n                            }\n                        } else if (response.status === 401) {\n                            await refreshSession();\n                        }\n                    } catch (e) {\n                    // Use cached user if network fails\n                    }\n                }\n            }\n            setIsLoading(false);\n        };\n        checkAuth();\n    }, []); // Remove refreshSession from dependencies\n    const login = async (email, password)=>{\n        setIsLoading(true);\n        try {\n            const response = await fetch(\"/api/auth/login\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    username: email,\n                    password\n                })\n            });\n            if (!response.ok) {\n                const error = await response.json();\n                throw new Error(error.error || \"Login failed\");\n            }\n            const data = await response.json();\n            storeTokens(data.access, data.refresh);\n            const userObj = {\n                id: data.user.id,\n                email: data.user.email,\n                fullName: \"\".concat(data.user.first_name || \"\", \" \").concat(data.user.last_name || \"\").trim(),\n                displayName: data.user.username,\n                role: data.user.role\n            };\n            localStorage.setItem(\"user\", JSON.stringify(userObj));\n            setUser(userObj);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const register = async (fullName, email, password, role)=>{\n        setIsLoading(true);\n        try {\n            const names = fullName.trim().split(\" \");\n            const firstName = names[0];\n            const lastName = names.slice(1).join(\" \") || \".\";\n            const response = await fetch(\"/api/auth/register\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    username: email,\n                    email,\n                    password,\n                    first_name: firstName,\n                    last_name: lastName,\n                    role: role\n                })\n            });\n            if (!response.ok) {\n                const error = await response.json();\n                throw new Error(error.error || \"Registration failed\");\n            }\n            const data = await response.json();\n            storeTokens(data.access, data.refresh);\n            const userObj = {\n                id: data.user.id,\n                email: data.user.email,\n                fullName: \"\".concat(data.user.first_name || \"\", \" \").concat(data.user.last_name || \"\").trim(),\n                displayName: data.user.username,\n                role: data.user.role\n            };\n            localStorage.setItem(\"user\", JSON.stringify(userObj));\n            setUser(userObj);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    const logout = async ()=>{\n        try {\n            await fetch(\"/api/auth/logout\", {\n                method: \"POST\",\n                headers: getAuthHeader()\n            });\n        } finally{\n            clearTokens();\n            setUser(null);\n        }\n    };\n    const updateUser = (updatedData)=>{\n        if (user) {\n            const newUser = {\n                ...user,\n                ...updatedData\n            };\n            setUser(newUser);\n            localStorage.setItem(\"user\", JSON.stringify(newUser));\n        }\n    };\n    const hasPermission = (permission)=>{\n        if (!user) return false;\n        if (user.role === \"Admin\") return true;\n        if (user.role === \"Coach\") return [\n            \"analyze\",\n            \"view\"\n        ].includes(permission);\n        return false;\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AuthContext.Provider, {\n        value: {\n            user,\n            isLoading,\n            isAuthenticated: !!user,\n            isAdmin: (user === null || user === void 0 ? void 0 : user.role) === \"Admin\",\n            login,\n            register,\n            logout,\n            updateUser,\n            refreshSession,\n            hasPermission\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\user\\\\Desktop\\\\yoe\\\\src\\\\context\\\\AuthContext.tsx\",\n        lineNumber: 264,\n        columnNumber: 5\n    }, this);\n}\n_s(AuthProvider, \"yZAlR6qvWLPp+1WhEpt+uomv46c=\");\n_c = AuthProvider;\nfunction useAuth() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AuthContext);\n    if (context === undefined) {\n        throw new Error(\"useAuth must be used within an AuthProvider\");\n    }\n    return context;\n}\n_s1(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0L0F1dGhDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBU2U7QUFtQ2YsTUFBTUssNEJBQWNMLG9EQUFhQSxDQUE4Qk07QUFFL0QsTUFBTUMsb0JBQW9CLElBQUksS0FBSztBQUU1QixTQUFTQyxhQUFhLEtBQXFDO1FBQXJDLEVBQUVDLFFBQVEsRUFBMkIsR0FBckM7O0lBQzNCLE1BQU0sQ0FBQ0MsTUFBTUMsUUFBUSxHQUFHVCwrQ0FBUUEsQ0FBa0I7SUFDbEQsTUFBTSxDQUFDVSxRQUFRQyxVQUFVLEdBQUdYLCtDQUFRQSxDQUFvQjtJQUN4RCxNQUFNLENBQUNZLFdBQVdDLGFBQWEsR0FBR2IsK0NBQVFBLENBQUM7SUFFM0MsTUFBTWMsY0FBYyxTQUFDQyxhQUFxQkM7WUFBc0JDLDZFQUFvQjtRQUNsRixNQUFNQyxZQUFZQyxLQUFLQyxHQUFHLEtBQUtILFlBQVk7UUFDM0MsTUFBTUksWUFBd0I7WUFBRU47WUFBYUM7WUFBY0U7UUFBVTtRQUNyRVAsVUFBVVU7UUFDVkMsYUFBYUMsT0FBTyxDQUFDLGNBQWNDLEtBQUtDLFNBQVMsQ0FBQ0o7SUFDcEQ7SUFFQSxNQUFNSyxjQUFjO1FBQ2xCZixVQUFVO1FBQ1ZXLGFBQWFLLFVBQVUsQ0FBQztRQUN4QkwsYUFBYUssVUFBVSxDQUFDO0lBQzFCO0lBRUEsTUFBTUMsZ0JBQWdCMUIsa0RBQVdBLENBQUM7UUFDaEMsTUFBTTJCLGVBQWVMLEtBQUtNLEtBQUssQ0FBQ1IsYUFBYVMsT0FBTyxDQUFDLGlCQUFpQjtRQUN0RSxNQUFNaEIsY0FBY0wsQ0FBQUEsbUJBQUFBLDZCQUFBQSxPQUFRSyxXQUFXLE1BQUljLHlCQUFBQSxtQ0FBQUEsYUFBY2QsV0FBVztRQUNwRSxJQUFJLENBQUNBLGFBQWEsT0FBTyxDQUFDO1FBQzFCLE9BQU87WUFBRWlCLGVBQWUsVUFBc0IsT0FBWmpCO1FBQWM7SUFDbEQsR0FBRztRQUFDTDtLQUFPO0lBRVgsTUFBTXVC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QUNSQyxTQUFTVDtZQUNYO1FBQ0YsU0FBVTtZQUNSRjtZQUNBakIsUUFBUTtRQUNWO0lBQ0Y7SUFFQSxNQUFNb0UsYUFBYSxDQUFDQztRQUNsQixJQUFJdEUsTUFBTTtZQUNSLE1BQU11RSxVQUFVO2dCQUFFLEdBQUd2RSxJQUFJO2dCQUFFLEdBQUdzRSxXQUFXO1lBQUM7WUFDMUNyRSxRQUFRc0U7WUFDUnpELGFBQWFDLE9BQU8sQ0FBQyxRQUFRQyxLQUFLQyxTQUFTLENBQUNzRDtRQUM5QztJQUNGO0lBRUEsTUFBTUMsZ0JBQWdCLENBQUNDO1FBQ3JCLElBQUksQ0FBQ3pFLE1BQU0sT0FBTztRQUNsQixJQUFJQSxLQUFLdUQsSUFBSSxLQUFLLFNBQVMsT0FBTztRQUNsQyxJQUFJdkQsS0FBS3VELElBQUksS0FBSyxTQUFTLE9BQU87WUFBQztZQUFXO1NBQU8sQ0FBQ21CLFFBQVEsQ0FBQ0Q7UUFDL0QsT0FBTztJQUNUO0lBRUEscUJBQ0UsOERBQUM5RSxZQUFZZ0YsUUFBUTtRQUNuQkMsT0FBTztZQUNMNUU7WUFDQUk7WUFDQXlFLGlCQUFpQixDQUFDLENBQUM3RTtZQUNuQjhFLFNBQVM5RSxDQUFBQSxpQkFBQUEsMkJBQUFBLEtBQU11RCxJQUFJLE1BQUs7WUFDeEJHO1lBQ0FHO1lBQ0FPO1lBQ0FDO1lBQ0E1QztZQUNBK0M7UUFDRjtrQkFFQ3pFOzs7Ozs7QUFHUDtHQXhPZ0JEO0tBQUFBO0FBME9ULFNBQVNpRjs7SUFDZCxNQUFNQyxVQUFVekYsaURBQVVBLENBQUNJO0lBQzNCLElBQUlxRixZQUFZcEYsV0FBVztRQUN6QixNQUFNLElBQUlnRSxNQUFNO0lBQ2xCO0lBQ0EsT0FBT29CO0FBQ1Q7SUFOZ0JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb250ZXh0L0F1dGhDb250ZXh0LnRzeD82ZWU0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xyXG5cclxuaW1wb3J0IHtcclxuICBjcmVhdGVDb250ZXh0LFxyXG4gIHVzZUNvbnRleHQsXHJcbiAgdXNlU3RhdGUsXHJcbiAgdXNlRWZmZWN0LFxyXG4gIHVzZUNhbGxiYWNrLFxyXG4gIFJlYWN0Tm9kZSxcclxufSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbi8vIFNpbXBsaWZpZWQgVXNlciB0eXBlIGZvciBub3dcclxuaW50ZXJmYWNlIEF1dGhVc2VyIHtcclxuICBpZDogc3RyaW5nO1xyXG4gIGVtYWlsOiBzdHJpbmc7XHJcbiAgZnVsbE5hbWU6IHN0cmluZztcclxuICBkaXNwbGF5TmFtZTogc3RyaW5nO1xyXG4gIHJvbGU6IHN0cmluZztcclxufVxyXG5cclxuaW50ZXJmYWNlIEF1dGhUb2tlbnMge1xyXG4gIGFjY2Vzc1Rva2VuOiBzdHJpbmc7XHJcbiAgcmVmcmVzaFRva2VuOiBzdHJpbmc7XHJcbiAgZXhwaXJlc0F0OiBudW1iZXI7XHJcbn1cclxuXHJcbmludGVyZmFjZSBBdXRoQ29udGV4dFR5cGUge1xyXG4gIHVzZXI6IEF1dGhVc2VyIHwgbnVsbDtcclxuICBpc0xvYWRpbmc6IGJvb2xlYW47XHJcbiAgaXNBdXRoZW50aWNhdGVkOiBib29sZWFuO1xyXG4gIGlzQWRtaW46IGJvb2xlYW47XHJcbiAgbG9naW46IChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIHJlZ2lzdGVyOiAoXHJcbiAgICBmdWxsTmFtZTogc3RyaW5nLFxyXG4gICAgZW1haWw6IHN0cmluZyxcclxuICAgIHBhc3N3b3JkOiBzdHJpbmcsXHJcbiAgICByb2xlOiBzdHJpbmdcclxuICApID0+IFByb21pc2U8dm9pZD47XHJcbiAgbG9nb3V0OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIHVwZGF0ZVVzZXI6ICh1c2VyOiBQYXJ0aWFsPEF1dGhVc2VyPikgPT4gdm9pZDtcclxuICByZWZyZXNoU2Vzc2lvbjogKCkgPT4gUHJvbWlzZTxib29sZWFuPjtcclxuICBoYXNQZXJtaXNzaW9uOiAocGVybWlzc2lvbjogc3RyaW5nKSA9PiBib29sZWFuO1xyXG59XHJcblxyXG5jb25zdCBBdXRoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8QXV0aENvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG5cclxuY29uc3QgUkVGUkVTSF9USFJFU0hPTEQgPSA1ICogNjAgKiAxMDAwO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEF1dGhQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9KSB7XHJcbiAgY29uc3QgW3VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGU8QXV0aFVzZXIgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBbdG9rZW5zLCBzZXRUb2tlbnNdID0gdXNlU3RhdGU8QXV0aFRva2VucyB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcclxuXHJcbiAgY29uc3Qgc3RvcmVUb2tlbnMgPSAoYWNjZXNzVG9rZW46IHN0cmluZywgcmVmcmVzaFRva2VuOiBzdHJpbmcsIGV4cGlyZXNJbjogbnVtYmVyID0gMzYwMCkgPT4ge1xyXG4gICAgY29uc3QgZXhwaXJlc0F0ID0gRGF0ZS5ub3coKSArIGV4cGlyZXNJbiAqIDEwMDA7XHJcbiAgICBjb25zdCBuZXdUb2tlbnM6IEF1dGhUb2tlbnMgPSB7IGFjY2Vzc1Rva2VuLCByZWZyZXNoVG9rZW4sIGV4cGlyZXNBdCB9O1xyXG4gICAgc2V0VG9rZW5zKG5ld1Rva2Vucyk7XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImF1dGhUb2tlbnNcIiwgSlNPTi5zdHJpbmdpZnkobmV3VG9rZW5zKSk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgY2xlYXJUb2tlbnMgPSAoKSA9PiB7XHJcbiAgICBzZXRUb2tlbnMobnVsbCk7XHJcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcImF1dGhUb2tlbnNcIik7XHJcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcInVzZXJcIik7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgZ2V0QXV0aEhlYWRlciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGNvbnN0IHN0b3JlZFRva2VucyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJhdXRoVG9rZW5zXCIpIHx8IFwibnVsbFwiKTtcclxuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gdG9rZW5zPy5hY2Nlc3NUb2tlbiB8fCBzdG9yZWRUb2tlbnM/LmFjY2Vzc1Rva2VuO1xyXG4gICAgaWYgKCFhY2Nlc3NUb2tlbikgcmV0dXJuIHt9O1xyXG4gICAgcmV0dXJuIHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FjY2Vzc1Rva2VufWAgfTtcclxuICB9LCBbdG9rZW5zXSk7XHJcblxyXG4gIGNvbnN0IHJlZnJlc2hTZXNzaW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xyXG4gICAgY29uc3Qgc3RvcmVkVG9rZW5zID0gdG9rZW5zIHx8IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJhdXRoVG9rZW5zXCIpIHx8IFwibnVsbFwiKTtcclxuICAgIFxyXG4gICAgaWYgKCFzdG9yZWRUb2tlbnM/LnJlZnJlc2hUb2tlbikge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvYXV0aC9yZWZyZXNoXCIsIHtcclxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHJlZnJlc2hUb2tlbjogc3RvcmVkVG9rZW5zLnJlZnJlc2hUb2tlbiB9KSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY2xlYXJUb2tlbnMoKTtcclxuICAgICAgICBzZXRVc2VyKG51bGwpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgc3RvcmVUb2tlbnMoZGF0YS5hY2Nlc3MsIGRhdGEucmVmcmVzaCwgMzYwMCk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIlRva2VuIHJlZnJlc2ggZmFpbGVkOlwiLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9LCBbdG9rZW5zXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoIXRva2VucykgcmV0dXJuO1xyXG4gICAgY29uc3QgdGltZVVudGlsRXhwaXJ5ID0gdG9rZW5zLmV4cGlyZXNBdCAtIERhdGUubm93KCk7XHJcbiAgICBjb25zdCByZWZyZXNoVGltZSA9IHRpbWVVbnRpbEV4cGlyeSAtIFJFRlJFU0hfVEhSRVNIT0xEO1xyXG4gICAgaWYgKHJlZnJlc2hUaW1lIDw9IDApIHtcclxuICAgICAgcmVmcmVzaFNlc3Npb24oKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgcmVmcmVzaFNlc3Npb24oKTtcclxuICAgIH0sIHJlZnJlc2hUaW1lKTtcclxuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gIH0sIFt0b2tlbnMsIHJlZnJlc2hTZXNzaW9uXSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBjaGVja0F1dGggPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHN0b3JlZFRva2VucyA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJhdXRoVG9rZW5zXCIpIHx8IFwibnVsbFwiKTtcclxuICAgICAgY29uc3Qgc3RvcmVkVXNlciA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ1c2VyXCIpIHx8IFwibnVsbFwiKTtcclxuXHJcbiAgICAgIGlmIChzdG9yZWRUb2tlbnMgJiYgc3RvcmVkVXNlcikge1xyXG4gICAgICAgIHNldFRva2VucyhzdG9yZWRUb2tlbnMpO1xyXG4gICAgICAgIHNldFVzZXIoc3RvcmVkVXNlcik7XHJcblxyXG4gICAgICAgIGlmIChzdG9yZWRUb2tlbnMuZXhwaXJlc0F0IC0gRGF0ZS5ub3coKSA8IFJFRlJFU0hfVEhSRVNIT0xEKSB7XHJcbiAgICAgICAgICBhd2FpdCByZWZyZXNoU2Vzc2lvbigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiL2FwaS9hdXRoL21lXCIsIHtcclxuICAgICAgICAgICAgICBoZWFkZXJzOiB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtzdG9yZWRUb2tlbnMuYWNjZXNzVG9rZW59YCB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgdXNlckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICAgICAgY29uc3QgdXNlck9iaiA9IHtcclxuICAgICAgICAgICAgICAgIGlkOiB1c2VyRGF0YS5pZCxcclxuICAgICAgICAgICAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbCxcclxuICAgICAgICAgICAgICAgIGZ1bGxOYW1lOiBgJHt1c2VyRGF0YS5maXJzdF9uYW1lIHx8ICcnfSAke3VzZXJEYXRhLmxhc3RfbmFtZSB8fCAnJ31gLnRyaW0oKSxcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiB1c2VyRGF0YS51c2VybmFtZSxcclxuICAgICAgICAgICAgICAgIHJvbGU6IHVzZXJEYXRhLnJvbGVcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIGlmIGl0J3MgYWN0dWFsbHkgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnNcclxuICAgICAgICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkodXNlck9iaikgIT09IEpTT04uc3RyaW5naWZ5KHN0b3JlZFVzZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRVc2VyKHVzZXJPYmopO1xyXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2VyXCIsIEpTT04uc3RyaW5naWZ5KHVzZXJPYmopKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcclxuICAgICAgICAgICAgICBhd2FpdCByZWZyZXNoU2Vzc2lvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAvLyBVc2UgY2FjaGVkIHVzZXIgaWYgbmV0d29yayBmYWlsc1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIGNoZWNrQXV0aCgpO1xyXG4gIH0sIFtdKTsgLy8gUmVtb3ZlIHJlZnJlc2hTZXNzaW9uIGZyb20gZGVwZW5kZW5jaWVzXHJcblxyXG4gIGNvbnN0IGxvZ2luID0gYXN5bmMgKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpID0+IHtcclxuICAgIHNldElzTG9hZGluZyh0cnVlKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCIvYXBpL2F1dGgvbG9naW5cIiwge1xyXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcm5hbWU6IGVtYWlsLCBwYXNzd29yZCB9KSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLmVycm9yIHx8IFwiTG9naW4gZmFpbGVkXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBzdG9yZVRva2VucyhkYXRhLmFjY2VzcywgZGF0YS5yZWZyZXNoKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHVzZXJPYmogPSB7XHJcbiAgICAgICAgaWQ6IGRhdGEudXNlci5pZCxcclxuICAgICAgICBlbWFpbDogZGF0YS51c2VyLmVtYWlsLFxyXG4gICAgICAgIGZ1bGxOYW1lOiBgJHtkYXRhLnVzZXIuZmlyc3RfbmFtZSB8fCAnJ30gJHtkYXRhLnVzZXIubGFzdF9uYW1lIHx8ICcnfWAudHJpbSgpLFxyXG4gICAgICAgIGRpc3BsYXlOYW1lOiBkYXRhLnVzZXIudXNlcm5hbWUsXHJcbiAgICAgICAgcm9sZTogZGF0YS51c2VyLnJvbGVcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwidXNlclwiLCBKU09OLnN0cmluZ2lmeSh1c2VyT2JqKSk7XHJcbiAgICAgIHNldFVzZXIodXNlck9iaik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHJlZ2lzdGVyID0gYXN5bmMgKGZ1bGxOYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcsIHJvbGU6IHN0cmluZykgPT4ge1xyXG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgbmFtZXMgPSBmdWxsTmFtZS50cmltKCkuc3BsaXQoJyAnKTtcclxuICAgICAgY29uc3QgZmlyc3ROYW1lID0gbmFtZXNbMF07XHJcbiAgICAgIGNvbnN0IGxhc3ROYW1lID0gbmFtZXMuc2xpY2UoMSkuam9pbignICcpIHx8ICcuJztcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCIvYXBpL2F1dGgvcmVnaXN0ZXJcIiwge1xyXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgXHJcbiAgICAgICAgICB1c2VybmFtZTogZW1haWwsIFxyXG4gICAgICAgICAgZW1haWwsIFxyXG4gICAgICAgICAgcGFzc3dvcmQsIFxyXG4gICAgICAgICAgZmlyc3RfbmFtZTogZmlyc3ROYW1lLCBcclxuICAgICAgICAgIGxhc3RfbmFtZTogbGFzdE5hbWUsXHJcbiAgICAgICAgICByb2xlOiByb2xlXHJcbiAgICAgICAgfSksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5lcnJvciB8fCBcIlJlZ2lzdHJhdGlvbiBmYWlsZWRcIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIHN0b3JlVG9rZW5zKGRhdGEuYWNjZXNzLCBkYXRhLnJlZnJlc2gpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgdXNlck9iaiA9IHtcclxuICAgICAgICBpZDogZGF0YS51c2VyLmlkLFxyXG4gICAgICAgIGVtYWlsOiBkYXRhLnVzZXIuZW1haWwsXHJcbiAgICAgICAgZnVsbE5hbWU6IGAke2RhdGEudXNlci5maXJzdF9uYW1lIHx8ICcnfSAke2RhdGEudXNlci5sYXN0X25hbWUgfHwgJyd9YC50cmltKCksXHJcbiAgICAgICAgZGlzcGxheU5hbWU6IGRhdGEudXNlci51c2VybmFtZSxcclxuICAgICAgICByb2xlOiBkYXRhLnVzZXIucm9sZVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJ1c2VyXCIsIEpTT04uc3RyaW5naWZ5KHVzZXJPYmopKTtcclxuICAgICAgc2V0VXNlcih1c2VyT2JqKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgbG9nb3V0ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgZmV0Y2goXCIvYXBpL2F1dGgvbG9nb3V0XCIsIHtcclxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICAgIGhlYWRlcnM6IGdldEF1dGhIZWFkZXIoKSxcclxuICAgICAgfSk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBjbGVhclRva2VucygpO1xyXG4gICAgICBzZXRVc2VyKG51bGwpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IHVwZGF0ZVVzZXIgPSAodXBkYXRlZERhdGE6IFBhcnRpYWw8QXV0aFVzZXI+KSA9PiB7XHJcbiAgICBpZiAodXNlcikge1xyXG4gICAgICBjb25zdCBuZXdVc2VyID0geyAuLi51c2VyLCAuLi51cGRhdGVkRGF0YSB9O1xyXG4gICAgICBzZXRVc2VyKG5ld1VzZXIpO1xyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInVzZXJcIiwgSlNPTi5zdHJpbmdpZnkobmV3VXNlcikpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhc1Blcm1pc3Npb24gPSAocGVybWlzc2lvbjogc3RyaW5nKTogYm9vbGVhbiA9PiB7XHJcbiAgICBpZiAoIXVzZXIpIHJldHVybiBmYWxzZTtcclxuICAgIGlmICh1c2VyLnJvbGUgPT09ICdBZG1pbicpIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKHVzZXIucm9sZSA9PT0gJ0NvYWNoJykgcmV0dXJuIFsnYW5hbHl6ZScsICd2aWV3J10uaW5jbHVkZXMocGVybWlzc2lvbik7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxBdXRoQ29udGV4dC5Qcm92aWRlclxyXG4gICAgICB2YWx1ZT17e1xyXG4gICAgICAgIHVzZXIsXHJcbiAgICAgICAgaXNMb2FkaW5nLFxyXG4gICAgICAgIGlzQXV0aGVudGljYXRlZDogISF1c2VyLFxyXG4gICAgICAgIGlzQWRtaW46IHVzZXI/LnJvbGUgPT09ICdBZG1pbicsXHJcbiAgICAgICAgbG9naW4sXHJcbiAgICAgICAgcmVnaXN0ZXIsXHJcbiAgICAgICAgbG9nb3V0LFxyXG4gICAgICAgIHVwZGF0ZVVzZXIsXHJcbiAgICAgICAgcmVmcmVzaFNlc3Npb24sXHJcbiAgICAgICAgaGFzUGVybWlzc2lvbixcclxuICAgICAgfX1cclxuICAgID5cclxuICAgICAge2NoaWxkcmVufVxyXG4gICAgPC9BdXRoQ29udGV4dC5Qcm92aWRlcj5cclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXV0aCgpIHtcclxuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBdXRoQ29udGV4dCk7XHJcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlQXV0aCBtdXN0IGJlIHVzZWQgd2l0aGluIGFuIEF1dGhQcm92aWRlclwiKTtcclxuICB9XHJcbiAgcmV0dXJuIGNvbnRleHQ7XHJcbn1cclxuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIkF1dGhDb250ZXh0IiwidW5kZWZpbmVkIiwiUkVGUkVTSF9USFJFU0hPTEQiLCJBdXRoUHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZXIiLCJzZXRVc2VyIiwidG9rZW5zIiwic2V0VG9rZW5zIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwic3RvcmVUb2tlbnMiLCJhY2Nlc3NUb2tlbiIsInJlZnJlc2hUb2tlbiIsImV4cGlyZXNJbiIsImV4cGlyZXNBdCIsIkRhdGUiLCJub3ciLCJuZXdUb2tlbnMiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsImNsZWFyVG9rZW5zIiwicmVtb3ZlSXRlbSIsImdldEF1dGhIZWFkZXIiLCJzdG9yZWRUb2tlbnMiLCJwYXJzZSIsImdldEl0ZW0iLCJBdXRob3JpemF0aW9uIiwicmVmcmVzaFNlc3Npb24iLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJvayIsImRhdGEiLCJqc29uIiwiYWNjZXNzIiwicmVmcmVzaCIsImVycm9yIiwiY29uc29sZSIsInRpbWVVbnRpbEV4cGlyeSIsInJlZnJlc2hUaW1lIiwidGltZXIiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY2hlY2tBdXRoIiwic3RvcmVkVXNlciIsInVzZXJEYXRhIiwidXNlck9iaiIsImlkIiwiZW1haWwiLCJmdWxsTmFtZSIsImZpcnN0X25hbWUiLCJsYXN0X25hbWUiLCJ0cmltIiwiZGlzcGxheU5hbWUiLCJ1c2VybmFtZSIsInJvbGUiLCJzdGF0dXMiLCJlIiwibG9naW4iLCJwYXNzd29yZCIsIkVycm9yIiwicmVnaXN0ZXIiLCJuYW1lcyIsInNwbGl0IiwiZmlyc3ROYW1lIiwibGFzdE5hbWUiLCJzbGljZSIsImpvaW4iLCJsb2dvdXQiLCJ1cGRhdGVVc2VyIiwidXBkYXRlZERhdGEiLCJuZXdVc2VyIiwiaGFzUGVybWlzc2lvbiIsInBlcm1pc3Npb24iLCJpbmNsdWRlcyIsIlByb3ZpZGVyIiwidmFsdWUiLCJpc0F1dGhlbnRpY2F0ZWQiLCJpc0FkbWluIiwidXNlQXV0aCIsImNvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/context/AuthContext.tsx\n"));

/***/ })

});